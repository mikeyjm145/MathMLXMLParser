var parserForRegMathBackup = (function() {
  "use strict";

	  /*
	   * Generated by PEG.js 0.9.0.
	   *
	   * http://pegjs.org/
	   */

	  function peg$subclass(child, parent) {
		function ctor() { this.constructor = child; }
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
	  }

	  function peg$SyntaxError(message, expected, found, location) {
		this.message  = message;
		this.expected = expected;
		this.found    = found;
		this.location = location;
		this.name     = "SyntaxError";

		if (typeof Error.captureStackTrace === "function") {
		  Error.captureStackTrace(this, peg$SyntaxError);
		}
	  }

	  peg$subclass(peg$SyntaxError, Error);

	  function peg$parse(input) {
		var options = arguments.length > 1 ? arguments[1] : {},
			parser  = this,

			peg$FAILED = {},

			peg$startRuleFunctions = { Expression: peg$parseExpression },
			peg$startRuleFunction  = peg$parseExpression,

			peg$c0 = "+",
			peg$c1 = { type: "literal", value: "+", description: "\"+\"" },
			peg$c2 = "-",
			peg$c3 = { type: "literal", value: "-", description: "\"-\"" },
			peg$c4 = "*",
			peg$c5 = { type: "literal", value: "*", description: "\"*\"" },
			peg$c6 = "/",
			peg$c7 = { type: "literal", value: "/", description: "\"/\"" },
			peg$c8 = "^",
			peg$c9 = { type: "literal", value: "^", description: "\"^\"" },
			peg$c10 = ";",
			peg$c11 = { type: "literal", value: ";", description: "\";\"" },
			peg$c12 = "=",
			peg$c13 = { type: "literal", value: "=", description: "\"=\"" },
			peg$c14 = function(first, rest) {
				  return combine(first, rest, {
					"+": function(left, right) { return left + toMathMLOperator("+") + right; },
					"-": function(left, right) { return left + toMathMLOperator("-") + right; },
					"*": function(left, right) { return left + toMathMLOperator("*") + right; },
					"/": function(left, right) { return toMathMLFraction(toMathMLRow(left) + toMathMLRow(right)); },
					"^": function(left, right) { return toMathMLPostscript(left, right); },
					";": function(left, right) { return left + right; },
					"=": function(left, right) { return left + toMathMLOperator("=") + right; }
				  });
				},
			peg$c15 = "(",
			peg$c16 = { type: "literal", value: "(", description: "\"(\"" },
			peg$c17 = ")",
			peg$c18 = { type: "literal", value: ")", description: "\")\"" },
			peg$c19 = function(expr) { return "<mtext>(</mtext>\n" + expr + "<mtext>)</mtext>\n"; },
			peg$c20 = "[",
			peg$c21 = { type: "literal", value: "[", description: "\"[\"" },
			peg$c22 = "]",
			peg$c23 = { type: "literal", value: "]", description: "\"]\"" },
			peg$c24 = function(expr) { return "<mtext>[</mtext>\n" + expr + "<mtext>]</mtext>\n"; },
			peg$c25 = "|",
			peg$c26 = { type: "literal", value: "|", description: "\"|\"" },
			peg$c27 = function(expr) { return "<mtext>|</mtext>\n" + expr + "<mtext>|</mtext>\n"; },
			peg$c28 = "{",
			peg$c29 = { type: "literal", value: "{", description: "\"{\"" },
			peg$c30 = "}",
			peg$c31 = { type: "literal", value: "}", description: "\"}\"" },
			peg$c32 = function(expr) { return  expr; },
			peg$c33 = function(expr) { return expr; },
			peg$c34 = { type: "other", description: "integer" },
			peg$c35 = /^[0-9]/,
			peg$c36 = { type: "class", value: "[0-9]", description: "[0-9]" },
			peg$c37 = function() { return toMathMLNumber(parseInt(text(), 10)); },
			peg$c38 = { type: "other", description: "identifier" },
			peg$c39 = /^[a-zA-Z]/,
			peg$c40 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
			peg$c41 = function() { return toMathMLIdentifier(text()); },
			peg$c42 = { type: "other", description: "eol" },
			peg$c43 = /^[;]/,
			peg$c44 = { type: "class", value: "[;]", description: "[;]" },
			peg$c45 = function() { return text(); },
			peg$c46 = { type: "other", description: "equal" },
			peg$c47 = /^[=]/,
			peg$c48 = { type: "class", value: "[=]", description: "[=]" },
			peg$c49 = { type: "other", description: "whitespace" },
			peg$c50 = /^[ s\t\n\r]/,
			peg$c51 = { type: "class", value: "[ \\s\\t\\n\\r]", description: "[ \\s\\t\\n\\r]" },

			peg$currPos          = 0,
			peg$savedPos         = 0,
			peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
			peg$maxFailPos       = 0,
			peg$maxFailExpected  = [],
			peg$silentFails      = 0,

			peg$result;

		if ("startRule" in options) {
		  if (!(options.startRule in peg$startRuleFunctions)) {
			throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
		  }

		  peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		}

		function text() {
		  return input.substring(peg$savedPos, peg$currPos);
		}

		function location() {
		  return peg$computeLocation(peg$savedPos, peg$currPos);
		}

		function expected(description) {
		  throw peg$buildException(
			null,
			[{ type: "other", description: description }],
			input.substring(peg$savedPos, peg$currPos),
			peg$computeLocation(peg$savedPos, peg$currPos)
		  );
		}

		function error(message) {
		  throw peg$buildException(
			message,
			null,
			input.substring(peg$savedPos, peg$currPos),
			peg$computeLocation(peg$savedPos, peg$currPos)
		  );
		}

		function peg$computePosDetails(pos) {
		  var details = peg$posDetailsCache[pos],
			  p, ch;

		  if (details) {
			return details;
		  } else {
			p = pos - 1;
			while (!peg$posDetailsCache[p]) {
			  p--;
			}

			details = peg$posDetailsCache[p];
			details = {
			  line:   details.line,
			  column: details.column,
			  seenCR: details.seenCR
			};

			while (p < pos) {
			  ch = input.charAt(p);
			  if (ch === "\n") {
				if (!details.seenCR) { details.line++; }
				details.column = 1;
				details.seenCR = false;
			  } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
				details.line++;
				details.column = 1;
				details.seenCR = true;
			  } else {
				details.column++;
				details.seenCR = false;
			  }

			  p++;
			}

			peg$posDetailsCache[pos] = details;
			return details;
		  }
		}

		function peg$computeLocation(startPos, endPos) {
		  var startPosDetails = peg$computePosDetails(startPos),
			  endPosDetails   = peg$computePosDetails(endPos);

		  return {
			start: {
			  offset: startPos,
			  line:   startPosDetails.line,
			  column: startPosDetails.column
			},
			end: {
			  offset: endPos,
			  line:   endPosDetails.line,
			  column: endPosDetails.column
			}
		  };
		}

		function peg$fail(expected) {
		  if (peg$currPos < peg$maxFailPos) { return; }

		  if (peg$currPos > peg$maxFailPos) {
			peg$maxFailPos = peg$currPos;
			peg$maxFailExpected = [];
		  }

		  peg$maxFailExpected.push(expected);
		}

		function peg$buildException(message, expected, found, location) {
		  function cleanupExpected(expected) {
			var i = 1;

			expected.sort(function(a, b) {
			  if (a.description < b.description) {
				return -1;
			  } else if (a.description > b.description) {
				return 1;
			  } else {
				return 0;
			  }
			});

			while (i < expected.length) {
			  if (expected[i - 1] === expected[i]) {
				expected.splice(i, 1);
			  } else {
				i++;
			  }
			}
		  }

		  function buildMessage(expected, found) {
			function stringEscape(s) {
			  function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

			  return s
				.replace(/\\/g,   '\\\\')
				.replace(/"/g,    '\\"')
				.replace(/\x08/g, '\\b')
				.replace(/\t/g,   '\\t')
				.replace(/\n/g,   '\\n')
				.replace(/\f/g,   '\\f')
				.replace(/\r/g,   '\\r')
				.replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
				.replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
				.replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
				.replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
			}

			var expectedDescs = new Array(expected.length),
				expectedDesc, foundDesc, i;

			for (i = 0; i < expected.length; i++) {
			  expectedDescs[i] = expected[i].description;
			}

			expectedDesc = expected.length > 1
			  ? expectedDescs.slice(0, -1).join(", ")
				  + " or "
				  + expectedDescs[expected.length - 1]
			  : expectedDescs[0];

			foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

			return "Expected " + expectedDesc + " but " + foundDesc + " found.";
		  }

		  if (expected !== null) {
			cleanupExpected(expected);
		  }

		  return new peg$SyntaxError(
			message !== null ? message : buildMessage(expected, found),
			expected,
			found,
			location
		  );
		}

		function peg$parseExpression() {
		  var s0, s1, s2, s3, s4, s5, s6, s7;

		  s0 = peg$currPos;
		  s1 = peg$parseParenthesis();
		  if (s1 === peg$FAILED) {
			s1 = peg$parseSquareBrackets();
			if (s1 === peg$FAILED) {
			  s1 = peg$parseAbsoluteValue();
			  if (s1 === peg$FAILED) {
				s1 = peg$parseInvisibleParenthesis();
			  }
			}
		  }
		  if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$currPos;
			s4 = peg$parse_();
			if (s4 !== peg$FAILED) {
			  if (input.charCodeAt(peg$currPos) === 43) {
				s5 = peg$c0;
				peg$currPos++;
			  } else {
				s5 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c1); }
			  }
			  if (s5 === peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 45) {
				  s5 = peg$c2;
				  peg$currPos++;
				} else {
				  s5 = peg$FAILED;
				  if (peg$silentFails === 0) { peg$fail(peg$c3); }
				}
				if (s5 === peg$FAILED) {
				  if (input.charCodeAt(peg$currPos) === 42) {
					s5 = peg$c4;
					peg$currPos++;
				  } else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c5); }
				  }
				  if (s5 === peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 47) {
					  s5 = peg$c6;
					  peg$currPos++;
					} else {
					  s5 = peg$FAILED;
					  if (peg$silentFails === 0) { peg$fail(peg$c7); }
					}
					if (s5 === peg$FAILED) {
					  if (input.charCodeAt(peg$currPos) === 94) {
						s5 = peg$c8;
						peg$currPos++;
					  } else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c9); }
					  }
					  if (s5 === peg$FAILED) {
						if (input.charCodeAt(peg$currPos) === 59) {
						  s5 = peg$c10;
						  peg$currPos++;
						} else {
						  s5 = peg$FAILED;
						  if (peg$silentFails === 0) { peg$fail(peg$c11); }
						}
						if (s5 === peg$FAILED) {
						  if (input.charCodeAt(peg$currPos) === 61) {
							s5 = peg$c12;
							peg$currPos++;
						  } else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c13); }
						  }
						}
					  }
					}
				  }
				}
			  }
			  if (s5 !== peg$FAILED) {
				s6 = peg$parse_();
				if (s6 !== peg$FAILED) {
				  s7 = peg$parseOtherLetterAndSymbols();
				  if (s7 !== peg$FAILED) {
					s4 = [s4, s5, s6, s7];
					s3 = s4;
				  } else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				  }
				} else {
				  peg$currPos = s3;
				  s3 = peg$FAILED;
				}
			  } else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			  }
			} else {
			  peg$currPos = s3;
			  s3 = peg$FAILED;
			}
			while (s3 !== peg$FAILED) {
			  s2.push(s3);
			  s3 = peg$currPos;
			  s4 = peg$parse_();
			  if (s4 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 43) {
				  s5 = peg$c0;
				  peg$currPos++;
				} else {
				  s5 = peg$FAILED;
				  if (peg$silentFails === 0) { peg$fail(peg$c1); }
				}
				if (s5 === peg$FAILED) {
				  if (input.charCodeAt(peg$currPos) === 45) {
					s5 = peg$c2;
					peg$currPos++;
				  } else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c3); }
				  }
				  if (s5 === peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 42) {
					  s5 = peg$c4;
					  peg$currPos++;
					} else {
					  s5 = peg$FAILED;
					  if (peg$silentFails === 0) { peg$fail(peg$c5); }
					}
					if (s5 === peg$FAILED) {
					  if (input.charCodeAt(peg$currPos) === 47) {
						s5 = peg$c6;
						peg$currPos++;
					  } else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c7); }
					  }
					  if (s5 === peg$FAILED) {
						if (input.charCodeAt(peg$currPos) === 94) {
						  s5 = peg$c8;
						  peg$currPos++;
						} else {
						  s5 = peg$FAILED;
						  if (peg$silentFails === 0) { peg$fail(peg$c9); }
						}
						if (s5 === peg$FAILED) {
						  if (input.charCodeAt(peg$currPos) === 59) {
							s5 = peg$c10;
							peg$currPos++;
						  } else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c11); }
						  }
						  if (s5 === peg$FAILED) {
							if (input.charCodeAt(peg$currPos) === 61) {
							  s5 = peg$c12;
							  peg$currPos++;
							} else {
							  s5 = peg$FAILED;
							  if (peg$silentFails === 0) { peg$fail(peg$c13); }
							}
						  }
						}
					  }
					}
				  }
				}
				if (s5 !== peg$FAILED) {
				  s6 = peg$parse_();
				  if (s6 !== peg$FAILED) {
					s7 = peg$parseOtherLetterAndSymbols();
					if (s7 !== peg$FAILED) {
					  s4 = [s4, s5, s6, s7];
					  s3 = s4;
					} else {
					  peg$currPos = s3;
					  s3 = peg$FAILED;
					}
				  } else {
					peg$currPos = s3;
					s3 = peg$FAILED;
				  }
				} else {
				  peg$currPos = s3;
				  s3 = peg$FAILED;
				}
			  } else {
				peg$currPos = s3;
				s3 = peg$FAILED;
			  }
			}
			if (s2 !== peg$FAILED) {
			  peg$savedPos = s0;
			  s1 = peg$c14(s1, s2);
			  s0 = s1;
			} else {
			  peg$currPos = s0;
			  s0 = peg$FAILED;
			}
		  } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		  }

		  return s0;
		}

		function peg$parseParenthesis() {
		  var s0, s1, s2, s3, s4, s5, s6;

		  s0 = peg$currPos;
		  if (input.charCodeAt(peg$currPos) === 40) {
			s1 = peg$c15;
			peg$currPos++;
		  } else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c16); }
		  }
		  if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			if (s2 !== peg$FAILED) {
			  s3 = peg$parseExpression();
			  if (s3 !== peg$FAILED) {
				s4 = peg$parse_();
				if (s4 !== peg$FAILED) {
				  if (input.charCodeAt(peg$currPos) === 41) {
					s5 = peg$c17;
					peg$currPos++;
				  } else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c18); }
				  }
				  if (s5 !== peg$FAILED) {
					s6 = peg$parse_();
					if (s6 !== peg$FAILED) {
					  peg$savedPos = s0;
					  s1 = peg$c19(s3);
					  s0 = s1;
					} else {
					  peg$currPos = s0;
					  s0 = peg$FAILED;
					}
				  } else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				  }
				} else {
				  peg$currPos = s0;
				  s0 = peg$FAILED;
				}
			  } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			  }
			} else {
			  peg$currPos = s0;
			  s0 = peg$FAILED;
			}
		  } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		  }
		  if (s0 === peg$FAILED) {
			s0 = peg$parseInteger();
			if (s0 === peg$FAILED) {
			  s0 = peg$parseIdentifier();
			}
		  }

		  return s0;
		}

		function peg$parseSquareBrackets() {
		  var s0, s1, s2, s3, s4, s5;

		  s0 = peg$currPos;
		  if (input.charCodeAt(peg$currPos) === 91) {
			s1 = peg$c20;
			peg$currPos++;
		  } else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c21); }
		  }
		  if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			if (s2 !== peg$FAILED) {
			  s3 = peg$parseExpression();
			  if (s3 !== peg$FAILED) {
				s4 = peg$parse_();
				if (s4 !== peg$FAILED) {
				  if (input.charCodeAt(peg$currPos) === 93) {
					s5 = peg$c22;
					peg$currPos++;
				  } else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c23); }
				  }
				  if (s5 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c24(s3);
					s0 = s1;
				  } else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				  }
				} else {
				  peg$currPos = s0;
				  s0 = peg$FAILED;
				}
			  } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			  }
			} else {
			  peg$currPos = s0;
			  s0 = peg$FAILED;
			}
		  } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		  }
		  if (s0 === peg$FAILED) {
			s0 = peg$parseInteger();
			if (s0 === peg$FAILED) {
			  s0 = peg$parseIdentifier();
			}
		  }

		  return s0;
		}

		function peg$parseAbsoluteValue() {
		  var s0, s1, s2, s3, s4, s5;

		  s0 = peg$currPos;
		  if (input.charCodeAt(peg$currPos) === 124) {
			s1 = peg$c25;
			peg$currPos++;
		  } else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c26); }
		  }
		  if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			if (s2 !== peg$FAILED) {
			  s3 = peg$parseExpression();
			  if (s3 !== peg$FAILED) {
				s4 = peg$parse_();
				if (s4 !== peg$FAILED) {
				  if (input.charCodeAt(peg$currPos) === 124) {
					s5 = peg$c25;
					peg$currPos++;
				  } else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c26); }
				  }
				  if (s5 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c27(s3);
					s0 = s1;
				  } else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				  }
				} else {
				  peg$currPos = s0;
				  s0 = peg$FAILED;
				}
			  } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			  }
			} else {
			  peg$currPos = s0;
			  s0 = peg$FAILED;
			}
		  } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		  }
		  if (s0 === peg$FAILED) {
			s0 = peg$parseInteger();
			if (s0 === peg$FAILED) {
			  s0 = peg$parseIdentifier();
			}
		  }

		  return s0;
		}

		function peg$parseInvisibleParenthesis() {
		  var s0, s1, s2, s3, s4, s5;

		  s0 = peg$currPos;
		  if (input.charCodeAt(peg$currPos) === 123) {
			s1 = peg$c28;
			peg$currPos++;
		  } else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c29); }
		  }
		  if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			if (s2 !== peg$FAILED) {
			  s3 = peg$parseExpression();
			  if (s3 !== peg$FAILED) {
				s4 = peg$parse_();
				if (s4 !== peg$FAILED) {
				  if (input.charCodeAt(peg$currPos) === 125) {
					s5 = peg$c30;
					peg$currPos++;
				  } else {
					s5 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c31); }
				  }
				  if (s5 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c32(s3);
					s0 = s1;
				  } else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				  }
				} else {
				  peg$currPos = s0;
				  s0 = peg$FAILED;
				}
			  } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			  }
			} else {
			  peg$currPos = s0;
			  s0 = peg$FAILED;
			}
		  } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		  }
		  if (s0 === peg$FAILED) {
			s0 = peg$parseInteger();
			if (s0 === peg$FAILED) {
			  s0 = peg$parseIdentifier();
			}
		  }

		  return s0;
		}

		function peg$parseOtherLetterAndSymbols() {
		  var s0, s1, s2, s3;

		  s0 = peg$currPos;
		  s1 = peg$parse_();
		  if (s1 !== peg$FAILED) {
			s2 = peg$parseExpression();
			if (s2 !== peg$FAILED) {
			  s3 = peg$parse_();
			  if (s3 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c33(s2);
				s0 = s1;
			  } else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			  }
			} else {
			  peg$currPos = s0;
			  s0 = peg$FAILED;
			}
		  } else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		  }
		  if (s0 === peg$FAILED) {
			s0 = peg$parseIdentifier();
			if (s0 === peg$FAILED) {
			  s0 = peg$parseInteger();
			  if (s0 === peg$FAILED) {
				s0 = peg$parseEOL();
				if (s0 === peg$FAILED) {
				  s0 = peg$parseEqual();
				}
			  }
			}
		  }

		  return s0;
		}

		function peg$parseInteger() {
		  var s0, s1, s2;

		  peg$silentFails++;
		  s0 = peg$currPos;
		  s1 = [];
		  if (peg$c35.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		  } else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c36); }
		  }
		  if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
			  s1.push(s2);
			  if (peg$c35.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			  } else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c36); }
			  }
			}
		  } else {
			s1 = peg$FAILED;
		  }
		  if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c37();
		  }
		  s0 = s1;
		  peg$silentFails--;
		  if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c34); }
		  }

		  return s0;
		}

		function peg$parseIdentifier() {
		  var s0, s1, s2;

		  peg$silentFails++;
		  s0 = peg$currPos;
		  s1 = [];
		  if (peg$c39.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		  } else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c40); }
		  }
		  if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
			  s1.push(s2);
			  if (peg$c39.test(input.charAt(peg$currPos))) {
				s2 = input.charAt(peg$currPos);
				peg$currPos++;
			  } else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c40); }
			  }
			}
		  } else {
			s1 = peg$FAILED;
		  }
		  if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c41();
		  }
		  s0 = s1;
		  peg$silentFails--;
		  if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c38); }
		  }

		  return s0;
		}

		function peg$parseEOL() {
		  var s0, s1, s2;

		  peg$silentFails++;
		  s0 = peg$currPos;
		  s1 = [];
		  if (peg$c43.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		  } else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c44); }
		  }
		  while (s2 !== peg$FAILED) {
			s1.push(s2);
			if (peg$c43.test(input.charAt(peg$currPos))) {
			  s2 = input.charAt(peg$currPos);
			  peg$currPos++;
			} else {
			  s2 = peg$FAILED;
			  if (peg$silentFails === 0) { peg$fail(peg$c44); }
			}
		  }
		  if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c45();
		  }
		  s0 = s1;
		  peg$silentFails--;
		  if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c42); }
		  }

		  return s0;
		}

		function peg$parseEqual() {
		  var s0, s1, s2;

		  peg$silentFails++;
		  s0 = peg$currPos;
		  s1 = [];
		  if (peg$c47.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		  } else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c48); }
		  }
		  while (s2 !== peg$FAILED) {
			s1.push(s2);
			if (peg$c47.test(input.charAt(peg$currPos))) {
			  s2 = input.charAt(peg$currPos);
			  peg$currPos++;
			} else {
			  s2 = peg$FAILED;
			  if (peg$silentFails === 0) { peg$fail(peg$c48); }
			}
		  }
		  if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c45();
		  }
		  s0 = s1;
		  peg$silentFails--;
		  if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c46); }
		  }

		  return s0;
		}

		function peg$parse_() {
		  var s0, s1;

		  peg$silentFails++;
		  s0 = [];
		  if (peg$c50.test(input.charAt(peg$currPos))) {
			s1 = input.charAt(peg$currPos);
			peg$currPos++;
		  } else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c51); }
		  }
		  while (s1 !== peg$FAILED) {
			s0.push(s1);
			if (peg$c50.test(input.charAt(peg$currPos))) {
			  s1 = input.charAt(peg$currPos);
			  peg$currPos++;
			} else {
			  s1 = peg$FAILED;
			  if (peg$silentFails === 0) { peg$fail(peg$c51); }
			}
		  }
		  peg$silentFails--;
		  if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c49); }
		  }

		  return s0;
		}


		  function combine(first, rest, combiners) {
			var result = first;
			var i = 0;
			for (i = 0; i < rest.length; i++) {
			  result = combiners[rest[i][1]](result, rest[i][3]);
			}

			return result;
		  }

		function toMathML(value) {
		  var startOfResult = result = "<math mode='display' xmlns='http://www.w3.org/1998/Math/MathML'>\n<mrow>";

		  var endOfResult = "</mrow>\n</math>";

		  return startOfResult + value + endOfResult;
		}

		function toMathMLOperator(operator) {
		  switch(operator){
		case '*': return "<mo>x</mo>\n";break;
		case '+': return "<mo>+</mo>\n";break;
		case '-': return "<mo>-</mo>\n";break;
		case '=': return "<mo>=</mo>\n";break;
		default: return "";
		}
		}

		function toMathMLNumber(number) {
		  return "<mn>" + number + "</mn>\n";
		}

		function toMathMLIdentifier(identifier) {
		  return "<mi>" + identifier + "</mi>\n";
		}

		function toMathMLRow(values) {
		  return "<mrow>\n" + values + "</mrow>\n";
		}

		function toMathMLFraction(value) {
		  return "<mfrac>\n" + value + "</mfrac>\n";
		}

		function toMathMLSquareRoot(value) {
		  return "<msqrt>\n" + value + "</msqrt>\n";
		}

		function toMathMLNthRoot(value, rootValue) {
		  return "<msqrt>\n" + value + "\n" + rootValue + "</msqrt>\n";
		}

		function toMathMLPostscript(postbase, postsuper) {
		  return "<msup>\n" + postbase + postsuper + "</msup>\n";
		}

		function toMathMLPrescript(presub, presuper) {
		  return "<mprescript/ >\n" + presub + "\n" + preSuper + "\n";
		}

		function toMathMLMultiScript(base, postsub, postsuper, presub, presuper) {
		  return 
		  "<mmultiscripts>\n" + base + "\n" + toMathMLPostscript(postsub, postsuper) + toMathMLPrescript(presub, presuper) + "</mmultiscripts>\n";
		}

		function toMathMLIntegral(start, end) {
		/*
			Come up with math operator for integral sign
		*/
		  return "<msubsup>" + "<mo>&#x222B;</mo>\n" + start + "\n" + end + "\n" + "</msubsup>\n";
		}

		function toMathMLMover(value) {
		  return "<mover accentover='true'>" + toMathMLRow(value) + "<mo>&#x23DE;</mo>\n" + "</mover>\n";
		}

		function toMathMLMunder(value) {
		  return "<munder accentunder='true'>" + toMathMLRow(value) + "<mo>&#x23DE;</mo>\n" + "\n" + "</munder>\n";
		}


		peg$result = peg$startRuleFunction();

		if (peg$result !== peg$FAILED && peg$currPos === input.length) {
		  return peg$result;
		} else {
		  if (peg$result !== peg$FAILED && peg$currPos < input.length) {
			peg$fail({ type: "end", description: "end of input" });
		  }

		  return peg$buildException(
			null,
			peg$maxFailExpected,
			peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
			peg$maxFailPos < input.length
			  ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
			  : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
		  );
		}
	  }

	  return {
		SyntaxError: peg$SyntaxError,
		parse:       peg$parse
	  };
}) ();

module.exports = parserForRegMathBackup;